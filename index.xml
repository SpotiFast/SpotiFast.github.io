<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SpotiFast Dokumentation (SWE2 2022)</title>
    <link>https://spotifast.github.io/</link>
    <description>Recent content on SpotiFast Dokumentation (SWE2 2022)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-de</language>
    
	<atom:link href="https://spotifast.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Automatisierte Tests</title>
      <link>https://spotifast.github.io/08_konzepte/01_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/08_konzepte/01_test/</guid>
      <description>8.1.1 Server Tests Der Server wurde in im Editor Visual Studio Code geschrieben. Damit ist es möglich, den Code zu testen und mit der Erweiterung Test grafisch dar zu stellen. Die Test befinden sich im Ordner &amp;lsquo;/scr&amp;rsquo;.
Test der Datenbank und der JSONValidation Es werden bei der Datenbank getestet, ob das Hinzufügen der Daten wie geplant funktioniert. Hierzu wird eine Mataklasse erstellt, die die Datenbankverbindung herstellt. Diese Klasse wird in den Testklassen verwendet.</description>
    </item>
    
    <item>
      <title>Backend-Sprache</title>
      <link>https://spotifast.github.io/09_entscheidungen/0.x_backendsprache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/09_entscheidungen/0.x_backendsprache/</guid>
      <description>9.1 Backend-Sprache Zur Fragestellung Welche Sprachen eigenen sich für die Verwendung als Backend-Sprache? Dieses sollte eine Sprache sein, welche die Einbindung eines OR-Mappers ermöglicht.
Betrachtete Alternativen Python (+) Positiv
  Python ist eine moderne, universell einsetzbare Programmiersprache, die leicht zu erlernen ist und eine große Community hat.   Python ist eine interpretierte Sprache, die eine hohe Flexibilität bietet.   Die Teammitglieder haben bereits Erfahrung mit Python.   (-) Negativ</description>
    </item>
    
    <item>
      <title>Grundbegriffe</title>
      <link>https://spotifast.github.io/12_glossar/01_grundbegriffe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/12_glossar/01_grundbegriffe/</guid>
      <description>12.1 Grundbegriffe VM Eine virtuelle Maschine, auch bekannt als VM, ist eine Art Software, die es ermöglicht, dass andere Betriebssysteme auf einem Computer emuliert werden. Dies wird durch das Ausführen der virtuellen Maschine auf dem Computer erreicht.
Client Ein Client ist eine Software, die auf einem Endgerät läuft und die Möglichkeit hat, mit einem Server zu kommunizieren. Der Client kann Anfragen an den Server senden und empfangen.
Server Ein Server ist ein Programm, das auf einem Computer läuft und mit einem Client kommuniziert.</description>
    </item>
    
    <item>
      <title>Qualitätsbaum</title>
      <link>https://spotifast.github.io/10_qualitaetsanforderungen/01_qualitaetsbaum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/10_qualitaetsanforderungen/01_qualitaetsbaum/</guid>
      <description>10.1 Qualitätsbaum Das folgende Bild gibt in Form eines sogenannten Qualitätsbaumes (englisch: Utitlty Tree) einen Überblick über die relevanten Qualitätsmerkmale und ordnet ihnen Szenarien als Beispiele zu. Die Qualitätsziele sind in der Abbildung ebenfalls enthalten und verweisen jeweils auf die Szenerien, welche sie illustrieren.
Bild: Zuordnung von Szenarien zu Qualitätsmerkmalen</description>
    </item>
    
    <item>
      <title>Sicherheit</title>
      <link>https://spotifast.github.io/11_risiken/01_sicherheit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/11_risiken/01_sicherheit/</guid>
      <description>11.1 Risiko: Sicherheit an API Das Risiko der Sicherheit an der API ist sehr hoch, da die API von außen erreichbar ist. Es ist daher wichtig, dass die API nur von vertrauenswürdigen Quellen erreichbar ist. Es wird nun eine minimale Authentifizierung eingeführt, um die Sicherheit zu erhöhen. Bei den Frames die an die API gesendet werden, wird ein Passwort mitgeschickt. Dieses Passwort ist Server- und Client-seitig gespeichert. Beim Empfangen der Frames wird das Passwort mit dem gespeicherten Passwort verglichen.</description>
    </item>
    
    <item>
      <title>Technisch</title>
      <link>https://spotifast.github.io/02_randbedingungen/01_technisch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/02_randbedingungen/01_technisch/</guid>
      <description>2.1 Technische Randbedingungen    Randbedingung Erläuterungen, Hintergrund     Hardwareausstattung Jeder Beteiligte benötigt eine moderate Hardwareausstattung. Die Entwicklung soll auf einem Laptop stattfinden. Um Testdaten zu generieren, wird ein Handy benötigt. Als Server steht eine VM auf dem Etmt-Server zur Verfügung.   Betriebssysteme Für die VM soll ein &amp;ldquo;für Server übliches&amp;rdquo; Betriebssystem verwendet werden. Die Entwicklung des Clients soll auf mehreren Betriebssystemen möglich sein, da im Team verschiedene Betriebssysteme verwendet werden (Windows 10 &amp;amp; macOS).</description>
    </item>
    
    <item>
      <title>Organisatorisch</title>
      <link>https://spotifast.github.io/02_randbedingungen/02_organisatorisch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/02_randbedingungen/02_organisatorisch/</guid>
      <description>2.2 Organisatorische Randbedingungen    Randbedingung Erläuterungen, Hintergrund     Zeitrahmen Der Zeitrahmen ist sehr begrenzt für dieses Projekt. Die Entwicklung soll innerhalb von 2 1&amp;frasl;2 Monaten abgeschlossen sein. Die Bearbeitungszeit begann am 4. Oktober 2022 und geht bis zum 23. Dezember 2022.   Organisation der Teams Um die Bearbeitungszeit zu verkürzen, wird das Projekt in zwei Teams bearbeitet. Die Teams arbeiten parallel und organisieren sich selbst.</description>
    </item>
    
    <item>
      <title>Qualitätsszenarien</title>
      <link>https://spotifast.github.io/10_qualitaetsanforderungen/02_qualitaetsszenarien/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/10_qualitaetsanforderungen/02_qualitaetsszenarien/</guid>
      <description>10.2 Qualitätsszenarien Die Anfangsbuchstaben der Bezeichner (IDs) der Szenarien in der folgenden Tabelle stehen jeweils für das übergeordnete Qualitätsmerkmal, P beispielsweise für Portierbarkeit. Diese Bezeichner finden auch im Qualitätsbaum Verwendung.
   ID Szenario erreicht     P01 Eine Benutzer:in kauft sich ein neues iPhone und besaß vorher ein Samsung Smartphone. Die App kann sie auch auf ihrem neuen Handy genau so gut benutzen.    B01 Ein Benutzer:in hat schon vorher Apps verwendet.</description>
    </item>
    
    <item>
      <title>Server</title>
      <link>https://spotifast.github.io/09_entscheidungen/02_server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/09_entscheidungen/02_server/</guid>
      <description>9.2 Server mit OR-Mapper Zur Fragestellung Sollten wir in unserem Projekt OR-Mapper verwenden, um die Verbindung zwischen der Anwendung und der Datenbank zu verwalten, oder sollten wir direkt auf die Datenbank zugreifen? Welche Vorteile bietet die Verwendung von OR-Mappern gegenüber direktem Zugriff auf die Datenbank?
Betrachtete Alternativen  Option (1):  Eine Alternative zu OR-Mappern ist der direkte Zugriff auf die Datenbank mithilfe von SQL (Structured Query Language). Dies bedeutet, dass die Anwendung direkt SQL-Anweisungen ausführt, um Daten aus der Datenbank abzurufen, zu aktualisieren oder zu löschen.</description>
    </item>
    
    <item>
      <title>Validierung</title>
      <link>https://spotifast.github.io/08_konzepte/02_validierung/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/08_konzepte/02_validierung/</guid>
      <description>8.2 Validierung In diesem Abschnitt wird auf die Validierung eingegangen, beispielhaft wird die Validierung des Frames gezeigt.
Der Konstruktor der JSONValidator-Klasse erwartet als Parameter einen String, der den Pfad zur JSON-Schema-Datei enthält. Die den Json als Dictionary, welche überprüft werden soll, sowie das Passwort, welches für die Verschlüsselung verwendet wurde. Außerdem die Version des Frames, die überprüft werden soll.
Password und Version sind optionale Parametrer. Wenn diese nicht angegeben werden, entfällt die Überprüfung des Passworts und der Version.</description>
    </item>
    
    <item>
      <title>Konventionen</title>
      <link>https://spotifast.github.io/02_randbedingungen/03_konventionen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/02_randbedingungen/03_konventionen/</guid>
      <description> 2.3 Konventionen    Konvention Erläuterungen, Hintergrund     Dokumentation Terminologie und Gliederung nach arc42. Die Dokumentation liegt im SpotiFastServer Repo im Ordner doc   Sprache Code einheitlich in Englisch (Bezeichner, Kommentare, Komponenten, Schnittstellen, JSON-Schema&amp;hellip;). Diagramme sollen möglichst nah am Code sein, daher auch in Englisch. Der Fließtext der arc42-Dokumentation ist in Deutsch zu verfassen.    </description>
    </item>
    
    <item>
      <title>SQLAlchemyAutoSchema</title>
      <link>https://spotifast.github.io/08_konzepte/03_sqlalchemyautoschema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/08_konzepte/03_sqlalchemyautoschema/</guid>
      <description>8.3 SQLAlchemyAutoSchema In diesem Abschnitt wird auf das SQLAlchemyAutoSchema eingegangen. Dieses Schema wird verwendet, um die Datenbanktabellen in JSON-Schemas zu übersetzen. Dieses ist nützlich, weil einige Anfragen vom Client kommen um zum Beispiel alle Positionen einer Route zu erhalten.
Beispiel anhand /getRoute/{routeId} Es folgt ein Beispiel mit einem Code Ausschnitt, wie das Schema für die Route erstellt wird.
class PositionSchemaWithoutRoute(SQLAlchemyAutoSchema): class Meta: model = Position load_instance = True include_relationships = True exclude = (&amp;quot;route&amp;quot;,)  Hierbei werden nun alle Attribute der Position ausgelesen und in das Schema geschrieben.</description>
    </item>
    
    <item>
      <title>Flutter</title>
      <link>https://spotifast.github.io/08_konzepte/05_flutter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/08_konzepte/05_flutter/</guid>
      <description>8.5 Flutter Die SpotiFast App wird in dem Framework Flutter und in der Programmiersprache Dart geschrieben. Dementsprechend werden auch die Konzepte von Flutter und Dart angewendet.
Die Oberfläche ist aus Widgets aufgebaut, die ineinander geschachtelt sind. Ein Widget beschreibt, wie seine Oberfläche aussehen soll. Zur Verschachtelung und Übergabe von anderen Widgets, den Kinder Widgets, wird die build-Methode überschrieben. Darin werden die Kinder Widgets aufgerufen und gebaut. Allgemein gibt es eine Unterscheidung zwischen Stateless und Stateful Widgets.</description>
    </item>
    
    <item>
      <title>Benutzungsoberfläche</title>
      <link>https://spotifast.github.io/08_konzepte/06_benutzungsoberfl%C3%A4che/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/08_konzepte/06_benutzungsoberfl%C3%A4che/</guid>
      <description>8.6 Benutzungsoberfläche Bei der Gestaltung der Benutzungsoberfläche wurde darauf geachtet sie ähnlich wie andere Apps zu gestalten, um die Bedienung zu erleichtern. Dafür wurden apptypische Bedienungselemente verwendet. Wie in der Graphik unten zu erkennen ist, gibt es im unteren Teil der Oberfläche eine Leiste, in welcher zwischen den verschiedenen Seiten gewechselt werden kann, wie man es beispielsweise auch von Apps wie Instagram und ähnlichem kennt. Des Weiteren gibt es oben links in der Ecke einen Button, mit welchem sich eine Liste an Auswählmöglichkeiten öffnet.</description>
    </item>
    
    <item>
      <title>Secrets / Tokens im Repo</title>
      <link>https://spotifast.github.io/08_konzepte/07_repo_templates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/08_konzepte/07_repo_templates/</guid>
      <description>8.7 Secrets / Tokens im Repo An einigen Stellen im Projekt ist es notwendig, Secrets, Tokens, Passwörter oder andere &amp;ldquo;geheime&amp;rdquo; Informationen im Code zu nutzen.
Damit diese Informationen einfach im Quellcode eingebunden werden können, ohne dass sie im Repo landen, werden .template Dateien verwendet.
  secret_password.py.template   secret_password.py     password: str = &#34;INSERT-PASSWORD-HERE&#34;    ist im Repo eingecheckt   password: str = &#34;</description>
    </item>
    
    <item>
      <title>Einstieg</title>
      <link>https://spotifast.github.io/04_loesungsstrategie/01_einstieg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/04_loesungsstrategie/01_einstieg/</guid>
      <description>4.1 Einstieg in die Lösungsstrategie Die folgende Tabelle stellt die Qualitätsziele von SpotiFast (→ 1.2 „Qualitätsziele“) passenden Architekturansätzen gegenüber, und erleichtert so einen Einstieg in die Lösung.
   Qualitätsziel Dem zuträgliche Ansätze in der Architektur     Einladende App Hierbei ist es wichtig, dass die App einfach zu bedienen ist und eine gute Usability bietet. Dazu gehört auch, dass die App intuitiv zu bedienen ist und keine unnötigen Schritte erfordert.</description>
    </item>
    
    <item>
      <title>Aufbau</title>
      <link>https://spotifast.github.io/04_loesungsstrategie/02_aufbau/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/04_loesungsstrategie/02_aufbau/</guid>
      <description>4.2 Der Aufbau von SpotiFast 4.2.1 Der Server Serverseitig soll SpotiFast in der Sprache Python realisiert werden. Der Server besteht aus zwei Teilen:
         API Anfragen der Clientseite entgegennehmen und Daten aus der Datenbank lesen/schreiben   Datenbank (DBMS - Postgres) Daten der Songs und der Route speichern    4.2.2 Der Client Die Clientseite soll in Dart realisiert werden, mit dem Framework Flutter.</description>
    </item>
    
    <item>
      <title>Spotify Autorisierung</title>
      <link>https://spotifast.github.io/06_laufzeitsicht/01_spotify_auth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/06_laufzeitsicht/01_spotify_auth/</guid>
      <description>6.1 Spotify Autorisierung Wie kriegen wir es hin, von unserer App aus auf die Spotify-Daten des Benutzers zuzugreifen?
Die Kommunikation mit Spotify erfolgt durch die Dart-Bibliothek spotify-dart. Diese Bibliothek ist eine Abstraktion der Spotify Web API und erlaubt einen vereinfachten Zugriff auf die API Endpunkte. Auch die Autorisierung via OAuth2 wird zum Teil von der Bibliothek übernommen. Nachfolgend ist der Autorisierungsprozess und der Einsatz der Bibliothek in einem Sequenzdiagramm dargestellt.</description>
    </item>
    
    <item>
      <title>Technischer Kontext</title>
      <link>https://spotifast.github.io/03_kontextabgrenzung/01_technischer_kontext/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/03_kontextabgrenzung/01_technischer_kontext/</guid>
      <description>3.1 Technischer Kontext Der Kontext, in welchem SpotiFast arbeitet, ist in der nachfolgenden Abbildung dargestellt.
Bild: Interaktion zwischen dem Benutzer, SpotiFast und Spotify (Teile des eigenen Systems sind grün markiert)
Der Benutzer interagiert auf seinem Endgerät mit dem Spotify Client und dem SpotiFast Client. Über den Spotify Client wird wie üblich Musik abgespielt. Im SpotiFast Client aktiviert/deaktiviert der Benutzer das Tracking und kann seine Statistiken/Auswertungen einsehen. Der SpotiFast Client nutzt die Development API von Spotify, um die aktuell abspielende Musik des Nutzers auszulesen.</description>
    </item>
    
    <item>
      <title>Überblick der Architektur</title>
      <link>https://spotifast.github.io/05_bausteinsicht/01_ueberblick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/05_bausteinsicht/01_ueberblick/</guid>
      <description>5.1 Überblick der Architektur Wie bereits aus der Kontextabgrenzung hervorgeht, lässt sich die SpotiFast Architektur in die zwei Bausteine &amp;ldquo;Client&amp;rdquo; und &amp;ldquo;Server&amp;rdquo; aufteilen. Im nachfolgenden Komponentendiagramm ist diese Architektur detaillierter dargestellt.
Bild: Übersicht der SpotiFast Architektur
Der Client besteht aus Model und View, wobei das Model die Aufgabe besitzt, mit anderen Komponenten des Systems zu kommunizieren. (→ 4.2.2 „Der Client“). Die Schnittstelle zu Spotify ist über die Developer API von Spotify realisiert und wird vom Model aus aufgerufen.</description>
    </item>
    
    <item>
      <title>Aufbau View</title>
      <link>https://spotifast.github.io/05_bausteinsicht/02_view/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/05_bausteinsicht/02_view/</guid>
      <description>5.2 Aufbau View 5.2.1 Appoberfläche Die Appoberfläche ist in verschiedene Seiten unterteilt. Diese werden von der Klasse MyApp abhängig davon aufgerufen, ob der Benutzer eingeloggt ist oder nicht. Wenn er eingeloggt ist, wird über die untere Auswahlleiste, die BottomNavbar, bestimmt, welche Seite sich öffnen soll. Per Default öffnet sich die erste Seite, die MapPage Seite. Der Benutzer kann durch dem Betätigen der BottomNavBar zwischen den verschiedenen Seiten wechseln.
Klassendiagramm der verschiedenen Seiten der Oberfläche</description>
    </item>
    
    <item>
      <title>Frames hinzufügen</title>
      <link>https://spotifast.github.io/06_laufzeitsicht/02_frames_hinzufuegen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/06_laufzeitsicht/02_frames_hinzufuegen/</guid>
      <description>6.2 Frames hinzufügen Eine der wichtigsten Aufgaben des Systems ist die Übertragung der Frames. Die Frames werden dabei zunächst im Client erzeugt und anschließend an den Server gesendet. Dieser Ablauf wird in den folgenden Abschnitten beschrieben.
Aus sicht des Clients Bild: Erzeugung und Übertragung eines Frames (Teile des eigenen Systems sind grün markiert)
Nach dem Starten des Trackings wird die User-ID (Benutzername) von Spotify abgefragt. Die UserId wird dann an den Server übermittelt und eine neue Routen-ID wird zurückgegeben.</description>
    </item>
    
    <item>
      <title>SpotiFast API</title>
      <link>https://spotifast.github.io/04_loesungsstrategie/03_spotifastapi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/04_loesungsstrategie/03_spotifastapi/</guid>
      <description>4.3 Die SpotiFast API Die SpotiFast API auf dem Server wird in Python mit der Bibliothek &amp;ldquo;Flask&amp;rdquo; implementiert. Sie empfängt Anfragen von der Clientseite und holt die dazugehörigen Daten aus der Datenbank ab.
Eine Fassade kann in diesem Fall sinnvoll sein, da sie als Schnittstelle dient, über die verschiedene Funktionen aufgerufen werden können, die entweder Daten aus der Datenbank abrufen oder an den Client senden.</description>
    </item>
    
    <item>
      <title>Aufbau Model</title>
      <link>https://spotifast.github.io/05_bausteinsicht/03_model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/05_bausteinsicht/03_model/</guid>
      <description>5.3 Aufbau Model Der interne Aufbau des Models ist im folgenden Klassendiagramm dargestellt. Das Klassendiagramm ist vereinfacht und dient der Verdeutlichung der Beziehungen zwischen den Klassen.
Ein detaillierte Beschreibung der Funktionalität ist dem Abschnitt → 6. „Laufzeitsicht“ zu entnehmen.
Bild: Klassendiagramm des Models
Neben den &amp;ldquo;aktiven&amp;rdquo; Klassen des Models werden auch die Routen und Frames durch Klassen repräsentiert. Diese dienen vor allem der übersichtlichen Weitergabe von Daten zwischen Methoden.</description>
    </item>
    
    <item>
      <title>Routen anzeigen</title>
      <link>https://spotifast.github.io/06_laufzeitsicht/03_route_anzeigen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/06_laufzeitsicht/03_route_anzeigen/</guid>
      <description>6.3 Routen anzeigen Aufgenommene Routen können vom Benutzer in der App auf einer Karte angezeigt werden. Der Ablauf hierfür ist im folgenden Diagramm dargestellt.
Bild: Auswählen und Anzeigen einer Route (Teile des eigenen Systems sind grün markiert)
Beim Aufbauen der App wird von der View die Liste aller Routen-IDs des Benutzers angefordert. Die Routen werden dann in einer Liste angezeigt, von wo aus der Benutzer eine der Routen auswählen kann.</description>
    </item>
    
    <item>
      <title>Aufbau API</title>
      <link>https://spotifast.github.io/05_bausteinsicht/04_aufbau_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/05_bausteinsicht/04_aufbau_api/</guid>
      <description>5.4 Aufbau API Im der folgenden Darstellung wird der Aufbau der API Zugriffe beschrieben.
Bild: API Zugriffe
Der APIFassade-Klasse werden von der API Funktionen zugewiesen, die aufgerufen werden. In der untenstehenden Tabelle sind alle URLs aufgelistet, die von der API bereitgestellt werden. Die APIFassade befindet sich in src/API/allAPI.py und kann direkt auf die Datenbank zugreifen oder Daten in die Datenbank schreiben. Wenn die Funktion addFrame aufgerufen wird, wird die Hilfsklasse FrameManager verwendet, um zu überprüfen, ob das Json-Schema korrekt ist.</description>
    </item>
    
    <item>
      <title>Aufbau Datenbank</title>
      <link>https://spotifast.github.io/05_bausteinsicht/05_aufbau_datenbank/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/05_bausteinsicht/05_aufbau_datenbank/</guid>
      <description>5.5 Aufbau Datenbank Bild: Physisches Schema der Datenbank
Im Folgenden wird das physische Schema der Datenbank beschrieben. Die Datenbank besteht aus 3 Tabellen, welche in der Abbildung dargestellt sind. Die Tabellen werden im Folgenden beschrieben.
Tabelle user Die Tabelle user enthält die Daten der Benutzer. Die Daten sind die UserId und das Land des Benutzers. Die UserId ist der Primärschlüssel der Tabelle. Die UserId wird von Spotify vergeben und ist eindeutig.</description>
    </item>
    
    <item>
      <title>Aufgabenstellung</title>
      <link>https://spotifast.github.io/01_einfuehrung/01_aufgabenstellung/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/01_einfuehrung/01_aufgabenstellung/</guid>
      <description>1.1 Aufgabenstellung Was ist SpotiFast? SpotiFast wertet aus, inwiefern das Tempo der Musik und auch andere Eigenschaften der Musik einen Einfluss auf das Fahrverhalten des Benutzers haben. Dazu gehören Eigenschaften wie Lautstärke, Tanzbarkeit, Instrumentalität und &amp;ldquo;Energie&amp;rdquo;. Des Weiteren bildet es auf einer Karte die verschiedenen Strecken ab, welche abhängig vom Lied und von der Geschwindigkeit anders farbig sind. Wann Daten gesammelt werden, entscheidet der Benutzer und jeder Zeitabschnitt wird in einer eigenen Route gespeichert, die einzeln ausgewertet wird.</description>
    </item>
    
    <item>
      <title>Qualitätsziele</title>
      <link>https://spotifast.github.io/01_einfuehrung/02_qualitaetsziele/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/01_einfuehrung/02_qualitaetsziele/</guid>
      <description>1.2 Qualitätsziele Die folgende Tabelle beschreibt die zentralen Qualitätsziele von SpotiFast, wobei die Reihenfolge eine grobe Orientierung bezüglich der Wichtigkeit vorgibt.
   Qualitätsziel Motivation und Erläuterung     Einladende App (Benutzbarkeit) Da SpotiFast eine App ist, die gerne und einfach von jedem genutzt werden soll, ist eine gute Verständlichkeit und Bedienbarkeit der App wichtig.   Sinnvolle Datenauswertung (Funktionalität) SpotiFast liefert dem Benutzer eine sinnvolle und richtige Datenauswertung.</description>
    </item>
    
    <item>
      <title>Stakeholder</title>
      <link>https://spotifast.github.io/01_einfuehrung/03_stakeholder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://spotifast.github.io/01_einfuehrung/03_stakeholder/</guid>
      <description> 1.3 Stakeholder Die folgende Tabelle stellt die Stakeholder von SpotiFast und ihre jeweilige Intention dar.
   Wer? Interesse, Bezug     Benutzer:innen  wollen auf anschauliche Weise angezeigt bekommen, ob und wie ihr Fahrverhalten von ihrem Musikgeschmack abhängt möchten ihre gefahrenen Routen und gehörten Lieder sehen wollen schnelle Reaktionszeiten und wenig Speicherverbrauch   Professor  Lernerfolg der Studenten strukturiertes und arbeitsteiliges Vorgehen im Projekt  Umsetzung der in den Vorlesungen vermittelten Inhalte (verteilte Systeme, Datenbanken, Entwurfsmuster, automatisierte Tests, &amp;hellip;)  Erfüllung des Auftrags    Studierende  Lernerfolg Erfüllung des Auftrags  Benutzung der App Spaß    </description>
    </item>
    
  </channel>
</rss>