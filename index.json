[
{
	"uri": "https://spotifast.github.io/08_konzepte/01_test/",
	"title": "Automatisierte Tests",
	"tags": [],
	"description": "",
	"content": " 8.1.1 Server Tests Der Server wurde in im Editor Visual Studio Code geschrieben. Damit ist es möglich, den Code zu testen und mit der Erweiterung Test grafisch dar zu stellen. Die Test befinden sich im Ordner \u0026lsquo;/scr\u0026rsquo;.\nTest der Datenbank und der JSONValidation Es werden bei der Datenbank getestet, ob das Hinzufügen der Daten wie geplant funktioniert. Hierzu wird eine Mataklasse erstellt, die die Datenbankverbindung herstellt. Diese Klasse wird in den Testklassen verwendet. Die Testklassen sind in der Datei \u0026lsquo;test_Datenbank.py\u0026rsquo; zu finden. Es wird ein Setup erstellt, der die Datenbankverbindung herstellt. Das tearDown wird immer nach dem Testen ausgeführt, egal ob der Test erfolgreich war oder nicht und schließt die Datenbankverbindung.\nEs wurden hierbei nun Test zu folgenden Klassen erstellt:   FrameManager   Position   JSONValidation  \nDie Test können in der Datei \u0026lsquo;test_*.py\u0026rsquo; gefunden werden. Es wurde einige Test gelöscht, da einige Funktionalitäten nicht mehr benötigt wurden.\n8.1.2 Client Tests Automatisierte Tests werden mit der Bibliothek flutter_test durchgeführt. Der Quellcode der Tests ist im Ordner test zu finden. Die Tests können am einfachsten über die IDE ausgeführt werden, alternativ aber auch über flutter test vom Terminal aus. (In VScode links das Icon \u0026ldquo;Testing\u0026rdquo; anklicken und dann \u0026ldquo;Run Tests\u0026rdquo;)\nAktuell beschränken sich die Tests im Client vor allem auf die Klassen des Models und auch hier hauptsächlich auf die \u0026ldquo;statischen\u0026rdquo; Klassen, die keine Zugriffe auf externe APIs benötigen. Grund dafür ist, dass beim Konzeptionieren des Models nicht die Testbarkeit im Vordergrund stand und die Klassen daher nicht so aufgebaut sind, dass sie einfach getestet werden können. Für umfassendere Tests muss das Model umstrukturiert werden, insbesondere sollten vermehrt Dependency Injections eingesetzt werden.\nBeispielsweise benötigt die Klasse Tracker zugriff auf SpotifyWrapper und die Methoden getLocation(). Beides sind externe Abhängigkeiten, die derzeit importiert werden und fest im Code verankert sind. Besser wäre es, diese Abhängigkeiten als Parameter im Konstruktor zu übergeben, sodass sie bei den Tests durch Mocks ersetzt werden können.\nDie Tests prüfen zudem, ob die Zugangsdaten für die APIs vorhanden sind (→ 8.7 „Secrets / Tokens im Repo“).\nReferenzen  Dependency Injection Entwurfsmuster : SWE2 Skript - Version 2022.10.01 - Seite 106 What is dependency injection? : https://stackoverflow.com/a/140655/11998115  "
},
{
	"uri": "https://spotifast.github.io/09_entscheidungen/0.x_backendsprache/",
	"title": "Backend-Sprache",
	"tags": [],
	"description": "",
	"content": " 9.1 Backend-Sprache Zur Fragestellung Welche Sprachen eigenen sich für die Verwendung als Backend-Sprache? Dieses sollte eine Sprache sein, welche die Einbindung eines OR-Mappers ermöglicht.\nBetrachtete Alternativen Python (+) Positiv\n  Python ist eine moderne, universell einsetzbare Programmiersprache, die leicht zu erlernen ist und eine große Community hat.   Python ist eine interpretierte Sprache, die eine hohe Flexibilität bietet.   Die Teammitglieder haben bereits Erfahrung mit Python.   (-) Negativ\n  Python ist eine interpretierte Sprache, die eine geringere Leistung bietet als eine kompilierte Sprache.   Bei einer großen Anzahl von einkommenden Anfragen kann die Leistung von Python abnehmen.   Java (+) Positiv\n  Java ist eine objektorientierte \u0026 kompilierte Sprache, die eine hohe Leistung bietet.   (-) Negativ\n  Die Teammitglieder haben keine Erfahrung mit Java.   Entscheidung Wir haben uns für Python entschieden, da wir bereits Erfahrung mit dieser Sprache haben. Die geringere Leistung ist für unser Projekt ein Problem, da wir eine hohe Anzahl von Anfragen erwarten. Die Zeit um sich in Java einzuarbeiten ist jedoch zu kurz, um diese Sprache für unser Projekt zu verwenden. Dieses sind entscheidende Faktoren, die uns zu der Entscheidung geführt hat.\n"
},
{
	"uri": "https://spotifast.github.io/12_glossar/01_grundbegriffe/",
	"title": "Grundbegriffe",
	"tags": [],
	"description": "",
	"content": " 12.1 Grundbegriffe VM Eine virtuelle Maschine, auch bekannt als VM, ist eine Art Software, die es ermöglicht, dass andere Betriebssysteme auf einem Computer emuliert werden. Dies wird durch das Ausführen der virtuellen Maschine auf dem Computer erreicht.\nClient Ein Client ist eine Software, die auf einem Endgerät läuft und die Möglichkeit hat, mit einem Server zu kommunizieren. Der Client kann Anfragen an den Server senden und empfangen.\nServer Ein Server ist ein Programm, das auf einem Computer läuft und mit einem Client kommuniziert. Der Server kann Anfragen des Clients entgegennehmen und Daten an den Client senden.\nSpotify Spotify ist eine Plattform, die es ermöglicht, Musik in hoher Qualität zu streamen. Mit Spotify kann man Musik hören, ohne sie vorher herunterladen zu müssen. Es handelt sich hierbei um einen Musikstreaming-Dienst.\n"
},
{
	"uri": "https://spotifast.github.io/10_qualitaetsanforderungen/01_qualitaetsbaum/",
	"title": "Qualitätsbaum",
	"tags": [],
	"description": "Der Qualitätsbaum gibt einen Überblick über die relevanten Qualitätsmerkmale und zeigt die ihnen jeweils zugeordneten Qualitätsszenarien.",
	"content": " 10.1 Qualitätsbaum Das folgende Bild gibt in Form eines sogenannten Qualitätsbaumes (englisch: Utitlty Tree) einen Überblick über die relevanten Qualitätsmerkmale und ordnet ihnen Szenarien als Beispiele zu. Die Qualitätsziele sind in der Abbildung ebenfalls enthalten und verweisen jeweils auf die Szenerien, welche sie illustrieren.\nBild: Zuordnung von Szenarien zu Qualitätsmerkmalen\n"
},
{
	"uri": "https://spotifast.github.io/11_risiken/01_sicherheit/",
	"title": "Sicherheit",
	"tags": [],
	"description": "",
	"content": " 11.1 Risiko: Sicherheit an API Das Risiko der Sicherheit an der API ist sehr hoch, da die API von außen erreichbar ist. Es ist daher wichtig, dass die API nur von vertrauenswürdigen Quellen erreichbar ist. Es wird nun eine minimale Authentifizierung eingeführt, um die Sicherheit zu erhöhen. Bei den Frames die an die API gesendet werden, wird ein Passwort mitgeschickt. Dieses Passwort ist Server- und Client-seitig gespeichert. Beim Empfangen der Frames wird das Passwort mit dem gespeicherten Passwort verglichen. Wenn die Passwörter übereinstimmen, wird die Frame weiterverarbeitet. Wenn die Passwörter nicht übereinstimmen, wird die Frame verworfen.\nRisikominderung Die Risikominderung kann wie folgt aussehen:\n HMAC Authentication Digital Signature OAuth  "
},
{
	"uri": "https://spotifast.github.io/02_randbedingungen/01_technisch/",
	"title": "Technisch",
	"tags": [],
	"description": "",
	"content": " 2.1 Technische Randbedingungen    Randbedingung Erläuterungen, Hintergrund     Hardwareausstattung Jeder Beteiligte benötigt eine moderate Hardwareausstattung. Die Entwicklung soll auf einem Laptop stattfinden. Um Testdaten zu generieren, wird ein Handy benötigt. Als Server steht eine VM auf dem Etmt-Server zur Verfügung.   Betriebssysteme Für die VM soll ein \u0026ldquo;für Server übliches\u0026rdquo; Betriebssystem verwendet werden. Die Entwicklung des Clients soll auf mehreren Betriebssystemen möglich sein, da im Team verschiedene Betriebssysteme verwendet werden (Windows 10 \u0026amp; macOS). Die finale Ausführung des Clients soll auf allen üblichen Smartphone-Betriebssystemen möglich sein (Android \u0026amp; iOS)   Fremdsoftware Falls zur Lösung Fremdsoftware hinzugezogen wird, sollte diese idealerweise frei verfügbar und kostenlos sein. Die Schwelle der Verwendung wird auf diese Weise niedrig gehalten.    "
},
{
	"uri": "https://spotifast.github.io/00_ueberblick/",
	"title": "Was ist SpotiFast?",
	"tags": [],
	"description": "Was ist SpotiFast?",
	"content": " Die Idee \"Fahren wohl Leute die Jazz hören generell langsamer als Leute die Techno hören?\"  \"Hmm, keine Ahnung. Jemand sollte mal eine App programmieren, die das herausfindet.\"  \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (based on real events)  Die grundlegende Idee dieses Projektes ist es, das Fahrverhalten von Autofahrer:innen mit ihrem Musikgeschmack in Verbindung zu setzen. Dabei steht im Kern die Hpytothese, dass bestimmte Musikgenres mit bestimmten Fahrverhalten assoziiert werden können.\nIm Rahmen des Moduls Software Engineering 2 wird eine Anwendung entwickelt werden, die diese Hypothese überprüft. Eine wichtige Rolle spielt dabei auch das methodische Vorgehen der Softwareentwicklung, welches im Rahmen dieses Moduls vermittelt wird.\n"
},
{
	"uri": "https://spotifast.github.io/01_einfuehrung/",
	"title": "Einführung und Ziele",
	"tags": [],
	"description": "Dieser Abschnitt führt in die Aufgabenstellung ein und skizziert die Ziele, die im Rahmen dieses Projekts erreicht werden sollen.",
	"content": " Abschnitt 1 Einführung und Ziele Dieser Abschnitt führt in die Aufgabenstellung ein und skizziert die Ziele, die im Rahmen dieses Projekts erreicht werden sollen.\n"
},
{
	"uri": "https://spotifast.github.io/02_randbedingungen/02_organisatorisch/",
	"title": "Organisatorisch",
	"tags": [],
	"description": "",
	"content": " 2.2 Organisatorische Randbedingungen    Randbedingung Erläuterungen, Hintergrund     Zeitrahmen Der Zeitrahmen ist sehr begrenzt für dieses Projekt. Die Entwicklung soll innerhalb von 2 1\u0026frasl;2 Monaten abgeschlossen sein. Die Bearbeitungszeit begann am 4. Oktober 2022 und geht bis zum 23. Dezember 2022.   Organisation der Teams Um die Bearbeitungszeit zu verkürzen, wird das Projekt in zwei Teams bearbeitet. Die Teams arbeiten parallel und organisieren sich selbst. Hierbei ist es wichtig, dass die Teams sich nicht gegenseitig behindern.   Vorgehen Zunächst soll bis zur KW 45 das MVP (Minimum Viable Product) entwickelt werden. Danach wird das Projekt in der KW 46 in die nächste Stufe überführt. Nach der Überführung werden nun weiter Features entwickelt.   Kommunikation Jede woche wird in einem ca. 30-minütigen Meeting mit dem Professor der aktuelle Stand vorgestellt und etwaige Fragen geklärt. Im Team wird hauptsächlich via Microsoft Teams kommuniziert.   Skills der Beteiligten Die Beteiligten haben unterschiedliche Skills. Mathis hat einige Erfahrungen in Dart und Flutter. Jan hat Erfahrungen mit Python und dem ORM SQLAlchemy.   Versionskontrolle Die Versionskontrolle erfolgt mit Github. Hier wird in zwei Repositories gearbeitet: SpotiFastClient für den Quellcode der App und SpotiFastServer für den Quellcode des Servers. Die Dokumentation wird im Server-Repo abgelegt. Bugs, Todos und zu klärende Punkte werden in einem \u0026ldquo;Github Project\u0026rdquo; verwaltet.    Referenzen  About GitHub Projects: https://docs.github.com/en/issues/planning-and-tracking-with-projects/learning-about-projects/about-projects  "
},
{
	"uri": "https://spotifast.github.io/10_qualitaetsanforderungen/02_qualitaetsszenarien/",
	"title": "Qualitätsszenarien",
	"tags": [],
	"description": "Diese Qualitätsszenarien (oder Bewertungsszenarien) konkretisieren die Qualitätsziele.",
	"content": " 10.2 Qualitätsszenarien Die Anfangsbuchstaben der Bezeichner (IDs) der Szenarien in der folgenden Tabelle stehen jeweils für das übergeordnete Qualitätsmerkmal, P beispielsweise für Portierbarkeit. Diese Bezeichner finden auch im Qualitätsbaum Verwendung.\n   ID Szenario erreicht     P01 Eine Benutzer:in kauft sich ein neues iPhone und besaß vorher ein Samsung Smartphone. Die App kann sie auch auf ihrem neuen Handy genau so gut benutzen.    B01 Ein Benutzer:in hat schon vorher Apps verwendet. Ihm ist nach spätestens paar Sekunden klar, wie die App zu bedienen ist. x   B02 Eine Benutzer:in möchte sich die Auswertungen für eine Route angucken. Diese werden ihr verständlich und anschaulich angezeigt.    F01 Ein Benutzer:in fährt mit einer Geschwindigkeit. Die ausgerechnete Geschwindigkeit darf maximal um 5 km/h von der tatsächlichen abweichen.    F02 Eine Benutzer:in guckt sich auf der Karte an, welche Lieder gehört wurden. Diese werden ihr korrekt angezeigt.    F03 Ein Benutzer:in kann nur auf seine eigenen ausgewerteten Routen zugreifen und auf Durchschnittswerte aller Benutzer, aber nicht auf Daten anderer Benutzer. x   E01 Eine Benutzer:in wählt eine Route aus. Diese wird ihr spätestens nach paar Sekunden auf der Karte beziehungsweise in den Graphen dargestellt.    E02 Bei einem Benutzer:in steigt der Akkuverbrauch durch die Benutzung der App höchstens ähnlich wie bei anderen Apps an. x    "
},
{
	"uri": "https://spotifast.github.io/02_randbedingungen/",
	"title": "Randbedingungen",
	"tags": [],
	"description": "Beim Lösungsentwurf waren zu Beginn verschiedene Randbedingungen zu beachten, sie wirken in der Lösung fort.",
	"content": " Abschnitt 2 Randbedingungen In diesem Abschnitt werden die Randbedingungen dargestellt, innerhalb derer die Umsetzung von SpotiFast erfolgt.\n"
},
{
	"uri": "https://spotifast.github.io/09_entscheidungen/02_server/",
	"title": "Server",
	"tags": [],
	"description": "",
	"content": " 9.2 Server mit OR-Mapper Zur Fragestellung Sollten wir in unserem Projekt OR-Mapper verwenden, um die Verbindung zwischen der Anwendung und der Datenbank zu verwalten, oder sollten wir direkt auf die Datenbank zugreifen? Welche Vorteile bietet die Verwendung von OR-Mappern gegenüber direktem Zugriff auf die Datenbank?\nBetrachtete Alternativen  Option (1):  Eine Alternative zu OR-Mappern ist der direkte Zugriff auf die Datenbank mithilfe von SQL (Structured Query Language). Dies bedeutet, dass die Anwendung direkt SQL-Anweisungen ausführt, um Daten aus der Datenbank abzurufen, zu aktualisieren oder zu löschen.\n Option (2):  OR-Mapper (Object-Relational Mapper) sind Werkzeuge, die es ermöglichen, die Beziehungen zwischen Objekten in der Anwendung und Daten in einer Datenbank abzubilden.\nOption (1): OR-Mapper (+) Positiv   Sie verbergen die Details der Datenbankimplementierung und -struktur und ermöglichen es, dass sich die Anwendung auf das Geschäftslogik-Modell konzentrieren kann.   Sie vereinfachen das Schreiben von Code, da sie eine Abstraktion von SQL-Anweisungen bieten und somit die Notwendigkeit, SQL direkt zu schreiben, eliminieren.   Sie ermöglichen eine einfachere Wartung und Erweiterung der Anwendung, da Änderungen an der Datenbankstruktur nicht direkt in den Anwendungscode übertragen werden müssen.   Sie können die Leistung verbessern, indem sie den Zugriff auf die Datenbank optimieren und sicherstellen, dass nur die benötigten Daten abgerufen werden.  \n(-) Negativ   Sie können zusätzliche Komplexität und Overhead zu einem Projekt hinzufügen, da sie eine weitere Schicht in der Anwendung darstellen.   Sie können die Leistung beeinträchtigen, da sie eine zusätzliche Abstraktionsebene zwischen der Anwendung und der Datenbank einführen.   Sie können schwierig zu debuggen sein, da Probleme, die in der Datenbank auftreten, möglicherweise nicht direkt sichtbar sind.   Sie sind möglicherweise nicht in allen Szenarien geeignet und es könnte Fälle geben, in denen der direkte Zugriff auf die Datenbank sinnvoller ist.  \nOption (2): Direkter Zugriff auf die Datenbank (+) Positiv\n  Der direkte Zugriff kann einfacher zu debuggen sein, da Probleme, die in der Datenbank auftreten, direkt sichtbar sind.   Der dirkte Zugriff kann in bestimmten Szenarien einfacher zu implementieren sein, insbesondere wenn das Projekt bereits viel Code hat, der direkt auf die Datenbank zugreift.   (-) Negativ\n  Der dirkte Zugriff erfordert, dass Entwickler SQL direkt schreiben, was zu längerem und komplizierterem Code führen kann.   Der dirkte Zugriff kann die Wartung und Erweiterung der Anwendung erschweren, da Änderungen an der Datenbankstruktur direkt in den Anwendungscode übertragen werden müssen.   Der dirkte Zugriff verbergt nicht die Details der Datenbankimplementierung und -struktur, was bedeutet, dass sich die Anwendung auf diese Details konzentrieren muss, anstatt sich auf die Geschäftslogik zu konzentrieren.   Entscheidung Unser Team hat sich dazu entschieden, OR-Mapper in unserem Projekt zu verwenden, da sie uns die Vorteile von direktem Zugriff auf die Datenbank und von OR-Mappern bieten. OR-Mapper ermöglichen es, dass sich Entwickler auf das Geschäftslogik-Modell konzentrieren können, anstatt sich um die Details der Datenbankimplementierung und -struktur zu kümmern. Sie stellen eine Abstraktion von SQL-Anweisungen bereit, die es ermöglicht, dass der Code übersichtlicher und einfacher zu schreiben ist. OR-Mapper verbergen außerdem die Details der Datenbankimplementierung und -struktur, was bedeutet, dass sich die Anwendung auf das Geschäftslogik-Modell konzentrieren kann.\n"
},
{
	"uri": "https://spotifast.github.io/08_konzepte/02_validierung/",
	"title": "Validierung",
	"tags": [],
	"description": "",
	"content": " 8.2 Validierung In diesem Abschnitt wird auf die Validierung eingegangen, beispielhaft wird die Validierung des Frames gezeigt.\nDer Konstruktor der JSONValidator-Klasse erwartet als Parameter einen String, der den Pfad zur JSON-Schema-Datei enthält. Die den Json als Dictionary, welche überprüft werden soll, sowie das Passwort, welches für die Verschlüsselung verwendet wurde. Außerdem die Version des Frames, die überprüft werden soll.\nPassword und Version sind optionale Parametrer. Wenn diese nicht angegeben werden, entfällt die Überprüfung des Passworts und der Version.\nUm die Validierung durchzuführen, wird die Methode validate() aufgerufen. Diese Methode gibt ein Boolean zurück, welches angibt, ob die Validierung erfolgreich war oder nicht. Wenn die Validierung nicht erfolgreich war, kann die Methode getErrors() aufgerufen werden, um die Fehlermeldungen zu erhalten.\nWenn getErrors() aufgerufen wird, ohne dass zuvor validate() aufgerufen wurde, wird diese Methode eine Exception werfen und führt die Validierung durch und gibt die Fehlermeldungen zurück.\n"
},
{
	"uri": "https://spotifast.github.io/03_kontextabgrenzung/",
	"title": "Kontextabgrenzung",
	"tags": [],
	"description": "In diesem Abschnitt wird der Aufbau von SpotiFast im Gesamtkontext dargestellt.",
	"content": " Abschnitt 3 Kontextabgrenzung In diesem Abschnitt wird der Aufbau von SpotiFast im Gesamtkontext dargestellt. Wie interagiert der Benutzer mit dem System? In welchen Abhängigkeiten zu anderen Systemen steht SpotiFast ?\n"
},
{
	"uri": "https://spotifast.github.io/02_randbedingungen/03_konventionen/",
	"title": "Konventionen",
	"tags": [],
	"description": "",
	"content": " 2.3 Konventionen    Konvention Erläuterungen, Hintergrund     Dokumentation Terminologie und Gliederung nach arc42. Die Dokumentation liegt im SpotiFastServer Repo im Ordner doc   Sprache Code einheitlich in Englisch (Bezeichner, Kommentare, Komponenten, Schnittstellen, JSON-Schema\u0026hellip;). Diagramme sollen möglichst nah am Code sein, daher auch in Englisch. Der Fließtext der arc42-Dokumentation ist in Deutsch zu verfassen.    "
},
{
	"uri": "https://spotifast.github.io/08_konzepte/03_sqlalchemyautoschema/",
	"title": "SQLAlchemyAutoSchema",
	"tags": [],
	"description": "",
	"content": " 8.3 SQLAlchemyAutoSchema In diesem Abschnitt wird auf das SQLAlchemyAutoSchema eingegangen. Dieses Schema wird verwendet, um die Datenbanktabellen in JSON-Schemas zu übersetzen. Dieses ist nützlich, weil einige Anfragen vom Client kommen um zum Beispiel alle Positionen einer Route zu erhalten.\nBeispiel anhand /getRoute/{routeId} Es folgt ein Beispiel mit einem Code Ausschnitt, wie das Schema für die Route erstellt wird.\nclass PositionSchemaWithoutRoute(SQLAlchemyAutoSchema): class Meta: model = Position load_instance = True include_relationships = True exclude = (\u0026quot;route\u0026quot;,)  Hierbei werden nun alle Attribute der Position ausgelesen und in das Schema geschrieben. Sowie die Beziehung zu der Route. Da diese aber nicht benötigt wird, wird sie ausgeschlossen (exclude).\ndef getRoute(self, id): with Session() as session: route = session.query(Route).get(id) positionList = session.query(Position).filter(Position.routeID == id).all() routeJson = RouteSchema().dump(route) positionJson = PositionSchemaWithoutRoute().dump(positionList, many=True) routeJson['positions'] = positionJson return Response.createResponse(RouteSchema(), routeJson, 200)  In dem oben geschriebenen Code wird nun die Route mit der ID aus der Datenbank geholt und die Positionen, die zu dieser Route gehören. Die Route und die Positionen werden dann in ein JSON. Die einzelnen Positionen werden dann in das RouteJson geschrieben und zurückgegeben. Hierbei wird denn folgendes beispielhaftes Json ausgegeben:\n{ \u0026quot;id\u0026quot;: 4, \u0026quot;positions\u0026quot;: [ { \u0026quot;creationTime\u0026quot;: \u0026quot;2022-12-05T14:04:33.942602\u0026quot;, \u0026quot;id\u0026quot;: 1, \u0026quot;latitude\u0026quot;: 52.613548, \u0026quot;longitude\u0026quot;: 8.363527, \u0026quot;trackID\u0026quot;: \u0026quot;4YXdayMSwqpJ3s93vtV5VC\u0026quot; }, { \u0026quot;creationTime\u0026quot;: \u0026quot;2022-12-05T14:04:34.877090\u0026quot;, \u0026quot;id\u0026quot;: 2, \u0026quot;latitude\u0026quot;: 52.613568, \u0026quot;longitude\u0026quot;: 8.362614, \u0026quot;trackID\u0026quot;: \u0026quot;4YXdayMSwqpJ3s93vtV5VC\u0026quot; } ], \u0026quot;user\u0026quot;: \u0026quot;JohnDoe\u0026quot; }  "
},
{
	"uri": "https://spotifast.github.io/04_loesungsstrategie/",
	"title": "Lösungstrategie",
	"tags": [],
	"description": "Dieser Abschnitt enthält einen stark verdichteten Architekturüberblick.",
	"content": " Abschnitt 4 Lösungstrategie In diesem Abschnitt wird die Lösungstrategie für die in → 1. „Einführung und Ziele“ aufgestellten Ziele vorgestellt.\n"
},
{
	"uri": "https://spotifast.github.io/05_bausteinsicht/",
	"title": "Bausteinsicht",
	"tags": [],
	"description": "Dieser Abschnitt beschreibt die Zerlegung von SpotiFast in seine Bausteine.",
	"content": " Abschnitt 5 Bausteinsicht Dieser Abschnitt beschreibt die Zerlegung von SpotiFast in seine Bausteine. Nach einem Überblick über die Gesamtarchitektur werden der Aufbau von Client und Server genauer beleuchtet.\n"
},
{
	"uri": "https://spotifast.github.io/08_konzepte/05_flutter/",
	"title": "Flutter",
	"tags": [],
	"description": "",
	"content": " 8.5 Flutter Die SpotiFast App wird in dem Framework Flutter und in der Programmiersprache Dart geschrieben. Dementsprechend werden auch die Konzepte von Flutter und Dart angewendet.\nDie Oberfläche ist aus Widgets aufgebaut, die ineinander geschachtelt sind. Ein Widget beschreibt, wie seine Oberfläche aussehen soll. Zur Verschachtelung und Übergabe von anderen Widgets, den Kinder Widgets, wird die build-Methode überschrieben. Darin werden die Kinder Widgets aufgerufen und gebaut. Allgemein gibt es eine Unterscheidung zwischen Stateless und Stateful Widgets. In dem unteren Beispielcode ist ein Stateless Widget zu sehen. Er besteht aus der überschriebenen build Methode, in welcher hier die Kinder Widgets MaterialApp und MyHomePage aufgerufen werden.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: const MyHomePage(title: 'Flutter Demo Home Page'), ); } }  Beispielcode: Stateless Widget\nEin Stateless Widget besteht aus einer Konfiguration, die sich nicht ändern kann, so dass sich die Darstellung des Widgets nicht ändert. Ein Stateful Widget ist abhängig von seiner Konfiguartion und seinem Status. Da sich der Status ändern kann, kann sich auch die Darstellung ändern. Es besteht aus zwei Klassen. Einem Widget mit den Konfigurationen und einem Status Objekt, welches in dem Widget aufgerufen wird. Durch die Änderung der Variablen ändert sich jedoch nicht automatisch die Oberfläche. Dafür wird die setState-Methode aufgerufen, welche Eigenschaften in einem Status-Objekt ändert und Updates in der Oberfläche auslöst. In dem unteren Beispielcode ist ein StatefulWidget MyHomePage zu sehen. MyHomePage beinhaltet die nicht veränderbare Konfiguration und ruft _MyHomePageState auf. _MyHomePageState enthält sich veränderbare Daten wie die Variable Counter. Des Weiteren enthält es die Methode setState(), welche aufgerufen wird, um den Counter Wert zu erhöhen. Durch die setState Methode wird auch gleichzeitig die Oberfläche neu gebaut, weswegen auch der Counter-Wert in der Oberfläche automatisch aktualisieret wird.\nclass MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State\u0026lt;MyHomePage\u0026gt; createState() =\u0026gt; _MyHomePageState(); } class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: \u0026lt;Widget\u0026gt;[ const Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: const Icon(Icons.add), ), ); } }  Beispielcode: Stateful Widget\nDie Kommunikation zwischen View und Model wird durch ValueNotifier und ValueListenableBuilder umgesetzt. Wenn sich der Wert eines ValueNotifiers ändert, wird dies an alle Stellen mit einem ValueListenableBuilder für diese Variable gemeldet. Die Widgets im ValueListenableBuilder werden dann mit dem Wert aktualisiert und neu gebaut. In dem unten zu sehenen Code ist eine beispielhafte Umsetzung zu sehen. Bei der Änderung des ausgesuchten Wertes in der Klasse Dropdown wird der ValueListenableBuilder in der Klasse Chart aufgerufen. Der neue Charttyp wird dem Chart als Attribut übergeben und das Widget wird neu gebaut und dargestellt.\nValueNotifier\u0026lt;String\u0026gt; selectedItem = ValueNotifier(\u0026quot;Area Chart\u0026quot;);  ValueListenableBuilder( valueListenable: _chartTypeButton.selectedItem, builder: (context, value, _) { return Column( children: [ Chart( _chartTypeButton.selectedItem.value, _chartData, \u0026quot;Average BPM depending on the velocity\u0026quot;, \u0026quot;Average BPM\u0026quot;), Chart( _chartTypeButton.selectedItem.value, _chartData, \u0026quot;Average loudness depending on the velocity\u0026quot;, \u0026quot;Average loudness\u0026quot;), ], ); }),  Beispielcode: ValueNotifier und ValueListenableBuilder\nReferenzen  Flutter Dokumentation: https://docs.flutter.dev/development/ui/interactive Flutter Widget Katalog: https://api.flutter.dev/flutter/widgets/ValueListenableBuilder-class.html  "
},
{
	"uri": "https://spotifast.github.io/08_konzepte/06_benutzungsoberfl%C3%A4che/",
	"title": "Benutzungsoberfläche",
	"tags": [],
	"description": "",
	"content": " 8.6 Benutzungsoberfläche Bei der Gestaltung der Benutzungsoberfläche wurde darauf geachtet sie ähnlich wie andere Apps zu gestalten, um die Bedienung zu erleichtern. Dafür wurden apptypische Bedienungselemente verwendet. Wie in der Graphik unten zu erkennen ist, gibt es im unteren Teil der Oberfläche eine Leiste, in welcher zwischen den verschiedenen Seiten gewechselt werden kann, wie man es beispielsweise auch von Apps wie Instagram und ähnlichem kennt. Des Weiteren gibt es oben links in der Ecke einen Button, mit welchem sich eine Liste an Auswählmöglichkeiten öffnet. Auch die Einstellungsseite ähnelt anderen Einstellungsseiten auf Smartphones, auch wenn sie noch nicht viele Einstellmöglichkeiten besitzt.\nBild: Oberfläche der App\n"
},
{
	"uri": "https://spotifast.github.io/06_laufzeitsicht/",
	"title": "Laufzeitsicht",
	"tags": [],
	"description": "In diesem Abschnitt wird das Verhalten des Systems zur Laufzeit beschrieben.",
	"content": " Abschnitt 6 Laufzeitsicht In diesem Abschnitt wird das Verhalten des Systems zur Laufzeit beschrieben. Hierbei wird im Detail auf die wichtigsten Vorgänge eingegangen, die zur Laufzeit des Systems auftreten.\n"
},
{
	"uri": "https://spotifast.github.io/08_konzepte/07_repo_templates/",
	"title": "Secrets / Tokens im Repo",
	"tags": [],
	"description": "",
	"content": " 8.7 Secrets / Tokens im Repo An einigen Stellen im Projekt ist es notwendig, Secrets, Tokens, Passwörter oder andere \u0026ldquo;geheime\u0026rdquo; Informationen im Code zu nutzen.\nDamit diese Informationen einfach im Quellcode eingebunden werden können, ohne dass sie im Repo landen, werden .template Dateien verwendet.\n  secret_password.py.template   secret_password.py     password: str = \"INSERT-PASSWORD-HERE\"    ist im Repo eingecheckt   password: str = \"correcthorsebatterystaple\"    ist nicht eingecheckt und explizit in .gitignore aufgeführt    Die .template Datei wird im Repo eingecheckt und enthält Platzhalter für alle Variablen, die im Quellcode benötigt werden.\nDer Quellcode referenziert die gewöhnliche .py Datei, das enthaltene Passwort kann als String einfach im Code verwendet werden.\nNach dem Klonen des Repos muss zunächst eine Kopie der .template Datei erstellt werden, bei der das .template im Namen entfernt wird. In der Kopie müssen dann alle Platzhalter durch die richtigen Werte ersetzt werden. Hierfür ist typischerweise eine detaillierte Anleitung in der Template-Datei enthalten.\nDiese Vorgehensweise mit den .template Dateien ist nicht perfekt. Die Tokens/Passwörter liegen in Klartext in einer Datei, wenn auch nur lokal. Diese Lösung hat sich jedoch im Rahmen des Projekts als ein guter Kompromiss zwischen Sicherheit und Komfort herausgestellt.\n"
},
{
	"uri": "https://spotifast.github.io/07_verteilungssicht/",
	"title": "Verteilungssicht",
	"tags": [],
	"description": "Verteilungssicht",
	"content": " Abschnitt 7 Verteilungssicht Dieser Abschnitt stellt nach arc42 das System aus Verteilungssicht dar. Im Kontext von SpotiFast ist diese Darstellung von geringer Bedeutung, daher wird der Abschnitt nicht weiter ausgearbeitet.\nDie Client-Server-Architektur von SpotiFast besteht nur aus wenigen Komponenten und ist nicht modular. Die Beschreibung der Architektur erfolgt daher in der Bausteinsicht (→ 5.1 „Überblick der Architektur“).\n"
},
{
	"uri": "https://spotifast.github.io/08_konzepte/",
	"title": "Querschnittliche Konzepte",
	"tags": [],
	"description": "Dieser Abschnitt beschreibt allgemeine Strukturen und Aspekte, die systemweit oder in Teilen des Systems gelten.",
	"content": " Abschnitt 8 Querschnittliche Konzepte In diesem Abschnitt wird auf wiederkehrende Konzepte und Muster eingegeangen, denen man im Projekt begegnet. Es werden besonders wichtige und interessante Konzepte vorgestellt.\n"
},
{
	"uri": "https://spotifast.github.io/09_entscheidungen/",
	"title": "Entscheidungen",
	"tags": [],
	"description": "Dieser Abschnitt lässt Euch zwei besonders interessante Entscheidungen beim Entwurf von SpotiFast im Detail nachvollziehen.",
	"content": " Abschnitt 9 Entscheidungen Dieser Abschnitt lässt Euch zwei besonders interessante Entscheidungen beim Entwurf von SpotiFast im Detail nachvollziehen.\n"
},
{
	"uri": "https://spotifast.github.io/04_loesungsstrategie/01_einstieg/",
	"title": "Einstieg",
	"tags": [],
	"description": "",
	"content": " 4.1 Einstieg in die Lösungsstrategie Die folgende Tabelle stellt die Qualitätsziele von SpotiFast (→ 1.2 „Qualitätsziele“) passenden Architekturansätzen gegenüber, und erleichtert so einen Einstieg in die Lösung.\n   Qualitätsziel Dem zuträgliche Ansätze in der Architektur     Einladende App Hierbei ist es wichtig, dass die App einfach zu bedienen ist und eine gute Usability bietet. Dazu gehört auch, dass die App intuitiv zu bedienen ist und keine unnötigen Schritte erfordert. Außerdem sollte die App eine gute Performance bieten, um eine gute Benutzererfahrung zu gewährleisten. Die Erwartungskonformität spielt hierbei ebenfalls eine große Rolle, da der Benutzer die Bedienerfahrung aus anderen Apps kennt und diese auch in der App von SpotiFast vorfinden sollte. Dieses kann z.B. durch Benutzung einer \u0026ldquo;NavBar\u0026rdquo; erreicht werden, welche sich im unterem Bereich des Bildschirmes befindet.   Sinnvolle Datenauswertung (Funktionalität) Die App sollte die Daten, aus der Spotify API und der Positions- und Geschwindigkeits-messung Sinnvoll kombinieren und auswerten. Die Spotify API liefert hierzu über den API-Endpunkt sogenannte \u0026ldquo;audio-features\u0026rdquo;, die nachfolgend aufgeführt sind. Indem diese Daten mit der Fahrgeschwindigkeit gegenüber gestellt werden, ist eine vielseitige Auswertung möglich.   Nutzbar auf iOS und Android (Portabilität) Die App sollte auf beiden Betriebssystemen lauffähig sein. Dieses kann durch die Verwendung von Dart und Flutter erreicht werden. Dieses ermöglicht die Entwicklung einer App für beide Betriebssysteme.    Audio-Features Nach folgenden \u0026ldquo;audio-features\u0026rdquo; kategorisiert Spotify seine Songs. Es handelt sich um Zahlenwerte, die über einen API-Endpunkt der Spotify API für jeden Song abgerufen werden können.\n danceability energy key loudness mode speechiness acousticness instrumentalness liveness valence tempo  Eine detaillierte Beschreibung dieser Werte ist in der Spotify API Referenz zu finden.\n"
},
{
	"uri": "https://spotifast.github.io/10_qualitaetsanforderungen/",
	"title": "Qualitätsanforderungen",
	"tags": [],
	"description": "Dieser Abschnitt beinhaltet konkrete Qualitätsszenarien, welche die zentralen Qualitätsziele, aber auch andere geforderte Qualitätseigenschaften besser fassen.",
	"content": " Abschnitt 10 Qualitätsanforderungen Dieser Abschnitt beinhaltet konkrete Qualitätsszenarien, welche die zentralen Qualitätsziele, aber auch andere geforderte Qualitätseigenschaften besser fassen. Sie ermöglichen es, Entscheidungsoptionen zu bewerten.\n"
},
{
	"uri": "https://spotifast.github.io/04_loesungsstrategie/02_aufbau/",
	"title": "Aufbau",
	"tags": [],
	"description": "",
	"content": " 4.2 Der Aufbau von SpotiFast 4.2.1 Der Server Serverseitig soll SpotiFast in der Sprache Python realisiert werden. Der Server besteht aus zwei Teilen:\n         API Anfragen der Clientseite entgegennehmen und Daten aus der Datenbank lesen/schreiben   Datenbank (DBMS - Postgres) Daten der Songs und der Route speichern    4.2.2 Der Client Die Clientseite soll in Dart realisiert werden, mit dem Framework Flutter. Flutter Apps sind typischerweise nach dem Model-View Prinzip aufgebaut. Die View ist die grafische Oberfläche, die dem Nutzer die Möglichkeit gibt, seine Routen darzustellen und das Tracking zu aktivieren. Das Model ist die Logik, die mit dem Server kommuniziert und periodisch Frames absendet. Desweiteren komuniziert das Model mit der Spotify API, um z.B. den aktuell laufenden Song zu ermitteln.\n"
},
{
	"uri": "https://spotifast.github.io/11_risiken/",
	"title": "Risiken",
	"tags": [],
	"description": "Die folgenden Risiken wurden zu Beginn des Vorhabens identifiziert.",
	"content": " Abschnitt 11 Risiken und technische Schulden Die folgenden Risiken wurden zu Beginn des Vorhabens als Probleme, die auftreten können, identifiziert. Sie beeinflussten die Planung der ersten drei Iterationen maßgeblich. Seit Abschluss der dritten Iteration gelten sie als beherrscht. Dieser Architekturüberblick zeigt die Risiken inklusive der damaligen Eventualfallplanung weiterhin, wegen ihres großen Einflusses auf die Lösung.\n"
},
{
	"uri": "https://spotifast.github.io/06_laufzeitsicht/01_spotify_auth/",
	"title": "Spotify Autorisierung",
	"tags": [],
	"description": "",
	"content": " 6.1 Spotify Autorisierung Wie kriegen wir es hin, von unserer App aus auf die Spotify-Daten des Benutzers zuzugreifen?\nDie Kommunikation mit Spotify erfolgt durch die Dart-Bibliothek spotify-dart. Diese Bibliothek ist eine Abstraktion der Spotify Web API und erlaubt einen vereinfachten Zugriff auf die API Endpunkte. Auch die Autorisierung via OAuth2 wird zum Teil von der Bibliothek übernommen. Nachfolgend ist der Autorisierungsprozess und der Einsatz der Bibliothek in einem Sequenzdiagramm dargestellt.\nBild: Autorisierungsprozess und Einsatz der Bibliothek (Teile des eigenen Systems sind grün markiert)\nFür die Verwendung der Spotify Web API ist es notwendig, die Anwendung bei Spotify zu registrieren. Dabei wird ein Client ID und ein Client Secret generiert, die für die Autorisierung benötigt werden.\nMit der Client ID und dem Client Secret wird gemäß OAuth2 von Spotify ein Grant angefordert. Dieser Grant enhält einen URL, der spezifisch für diesen Login-Vorgang ist. Teil dieses Grants ist ein URL zu https://accounts.spotify.com/authorize, welcher als Parameter eine \u0026ldquo;Code Challenge\u0026rdquo; enthält.\nDieser URL wird im nächsten Schritt aufgerufen und der Benutzer aufgefordert, sich bei Spotify anzumelden.\nBild: Login-Website https://accounts.spotify.com\nNach dem Eingeben der persönlichen Zugangsdaten wird die Code Challenge von Spotify gelöst und der \u0026ldquo;Code\u0026rdquo; zurückgegeben. Mit dem Code wird nun in der Bibliothek ein SpotifyApi Objekt erzeugt. Dieses ermöglicht die tatsächlichen Zugriffe auf die Spotify Web API.\nReferenzen  Spotify Developer Dashboard: https://developer.spotify.com/dashboard/applications Spotify Authorization Guide: https://developer.spotify.com/documentation/general/guides/authorization/ Spotify Bibliothek für Dart: https://pub.dev/packages/spotify  "
},
{
	"uri": "https://spotifast.github.io/03_kontextabgrenzung/01_technischer_kontext/",
	"title": "Technischer Kontext",
	"tags": [],
	"description": "",
	"content": " 3.1 Technischer Kontext Der Kontext, in welchem SpotiFast arbeitet, ist in der nachfolgenden Abbildung dargestellt.\nBild: Interaktion zwischen dem Benutzer, SpotiFast und Spotify (Teile des eigenen Systems sind grün markiert)\nDer Benutzer interagiert auf seinem Endgerät mit dem Spotify Client und dem SpotiFast Client. Über den Spotify Client wird wie üblich Musik abgespielt. Im SpotiFast Client aktiviert/deaktiviert der Benutzer das Tracking und kann seine Statistiken/Auswertungen einsehen. Der SpotiFast Client nutzt die Development API von Spotify, um die aktuell abspielende Musik des Nutzers auszulesen. Aufgenommenen Daten werden über eine API an den SpotiFast Server gesendet.\n"
},
{
	"uri": "https://spotifast.github.io/05_bausteinsicht/01_ueberblick/",
	"title": "Überblick der Architektur",
	"tags": [],
	"description": "",
	"content": " 5.1 Überblick der Architektur Wie bereits aus der Kontextabgrenzung hervorgeht, lässt sich die SpotiFast Architektur in die zwei Bausteine \u0026ldquo;Client\u0026rdquo; und \u0026ldquo;Server\u0026rdquo; aufteilen. Im nachfolgenden Komponentendiagramm ist diese Architektur detaillierter dargestellt.\nBild: Übersicht der SpotiFast Architektur\nDer Client besteht aus Model und View, wobei das Model die Aufgabe besitzt, mit anderen Komponenten des Systems zu kommunizieren. (→ 4.2.2 „Der Client“). Die Schnittstelle zu Spotify ist über die Developer API von Spotify realisiert und wird vom Model aus aufgerufen. Der Austausch mit dem Server erfolgt über die SpotiFast API, die vom Server bereitgestellt wird. Wird in der folgenden Dokumentation von der API gesprochen, so ist damit die SpotiFast API gemeint.\nDie SpotiFast API orientiert sich am REST-Prinzip. Ihre wesentliche Aufgabe ist es, API-Endpunkte bereitzustellen, mit denen der Client Routen in der Datenbank des Servers zu verwalten kann. Auf dem Server erfolgt keine Auswertung der Daten.\n"
},
{
	"uri": "https://spotifast.github.io/05_bausteinsicht/02_view/",
	"title": "Aufbau View",
	"tags": [],
	"description": "",
	"content": " 5.2 Aufbau View 5.2.1 Appoberfläche Die Appoberfläche ist in verschiedene Seiten unterteilt. Diese werden von der Klasse MyApp abhängig davon aufgerufen, ob der Benutzer eingeloggt ist oder nicht. Wenn er eingeloggt ist, wird über die untere Auswahlleiste, die BottomNavbar, bestimmt, welche Seite sich öffnen soll. Per Default öffnet sich die erste Seite, die MapPage Seite. Der Benutzer kann durch dem Betätigen der BottomNavBar zwischen den verschiedenen Seiten wechseln.\nKlassendiagramm der verschiedenen Seiten der Oberfläche\nAuf der eingeloggten Oberfläche, welche unten zu sehen ist, ist die BottomNav Klasse als untere Leiste erkennbar. Durch den Map-Button ist es möglich in die Oberfläche von MapPage zu wechseln, welche gerade abgebildet ist. Bei betätigen des Analysebutton in Analysepage und des Settingsbutton in die Settingspage.\nBild: Oberfläche der App\n5.2.2 Analyseseite Die Analyseseite, welche in der Klasse AnalysePage beshrieben wird, besteht aus den Widgets Chart und Dropdown. Mit den Dropdown Menüs können die Geschwindigkeit und der Charttyp ausgewählt werden. Mit Hilfe der Klasse Chart werden die verschiedenen Graphen dargestellt.\nKlassendiagramm der Analyseseite\nOffene Punkte Die dargestellten Diagramme auf der Analyseseite sind noch nicht mit ausgewerteten Daten verknüpft, sondern nur mit Beispielwerten zur Veranschaulichung.\n"
},
{
	"uri": "https://spotifast.github.io/06_laufzeitsicht/02_frames_hinzufuegen/",
	"title": "Frames hinzufügen",
	"tags": [],
	"description": "",
	"content": " 6.2 Frames hinzufügen Eine der wichtigsten Aufgaben des Systems ist die Übertragung der Frames. Die Frames werden dabei zunächst im Client erzeugt und anschließend an den Server gesendet. Dieser Ablauf wird in den folgenden Abschnitten beschrieben.\nAus sicht des Clients Bild: Erzeugung und Übertragung eines Frames (Teile des eigenen Systems sind grün markiert)\nNach dem Starten des Trackings wird die User-ID (Benutzername) von Spotify abgefragt. Die UserId wird dann an den Server übermittelt und eine neue Routen-ID wird zurückgegeben. User- und Routen-ID werden für die aktuelle Route im Client zwischengespeichert.\nDanach wird periodisch die Methode sendFrame() aufgerufen. Diese fragt zunächst die aktuellen Koordinaten vom GPS-Modul des Geräts ab. Danach wird von Spotify das Lied abgefragt, welches aktuell abgespielt wird. Zusammen mit weiteren Informationen wird daraus ein Frame erzeugt (→ 5.4 „Aufbau API“). Dieser wird anschließend an den Server gesendet. Aus der Antwort des Servers wird entnommen, ob das Hinzufügen erfolgreich war.\nAntwortet der Server mit einem Fehlercode - oder gar nicht - wird das Tracking beendet. Der Benutzer kann ebenfalls zu jedem Zeitpunkt das Tracking beenden. Es wird dann noch der aktuell laufende Sendevorgang abgeschlossen.\nAus sicht des Servers Ruft der Client den API-Endpunkt /addFrame auf, ist der Ablauf auf dem Server wie folgt:\n Es wird überprüft, ob die Json String valide ist. Ist dies nicht der Fall, wird der Frame verworfen. Diese Aufgabe übernimmt die Klasse FrameValidation Das Frame wird zur Datenbank hinzugefügt. Diese Aufgabe übernimmt die Klasse FrameManager.  FrameValidation Die Klasse FrameValidation überprüft, ob der Frame valide ist. Hierzu wird eine JsonSchema-Datei verwendet. Diese Datei wird in der Klasse JSONValidation geladen und mit dem Frame verglichen. Ist der Frame valide, wird true zurückgegeben. Ist der Frame nicht valide, wird false zurückgegeben. Desweitern wird auch überprüft, ob das Passwort oder die Version korrekt ist. Ist dies nicht der Fall, wird false zurückgegeben und eine Fehlermeldung ausgegeben. Es wird hier im Abschnitt → 8.2 „Validierung“ näher darauf eingegangen.\nFrameManager Die Klasse FrameManager ist für das Speichern des Frames in der Datenbank zuständig. Hierzu wird die Klasse FrameValidation verwendet. Ist der Frame valide, wird er in die Datenbank gespeichert. Ist der Frame nicht valide, wird er verworfen und die Fehlermeldung wird zurückgegeben. Wenn die alles Korrekt ist, wird der Frame geparst. Es Wird eine Position erstellt und zur Datenbank hinzugefügt. Bei dem Hinzufügen kann es zu einem Fehler kommen. Dieser wird abgefangen und eine Fehlermeldung wird zurückgegeben. Wenn keine Fehler aufgetreten sind, wird eine Erfolgsmeldung zurückgegeben.\n"
},
{
	"uri": "https://spotifast.github.io/12_glossar/",
	"title": "Glossar",
	"tags": [],
	"description": "Das folgende Glossar erklärt Begriffe aus der Schachwelt.",
	"content": " Abschnitt 12 Glossar Das folgende Glossar erklärt Begriffe aus dem Spotifast Projekt.\n"
},
{
	"uri": "https://spotifast.github.io/04_loesungsstrategie/03_spotifastapi/",
	"title": "SpotiFast API",
	"tags": [],
	"description": "",
	"content": " 4.3 Die SpotiFast API Die SpotiFast API auf dem Server wird in Python mit der Bibliothek \u0026ldquo;Flask\u0026rdquo; implementiert. Sie empfängt Anfragen von der Clientseite und holt die dazugehörigen Daten aus der Datenbank ab.\nEine Fassade kann in diesem Fall sinnvoll sein, da sie als Schnittstelle dient, über die verschiedene Funktionen aufgerufen werden können, die entweder Daten aus der Datenbank abrufen oder an den Client senden.\n"
},
{
	"uri": "https://spotifast.github.io/05_bausteinsicht/03_model/",
	"title": "Aufbau Model",
	"tags": [],
	"description": "",
	"content": " 5.3 Aufbau Model Der interne Aufbau des Models ist im folgenden Klassendiagramm dargestellt. Das Klassendiagramm ist vereinfacht und dient der Verdeutlichung der Beziehungen zwischen den Klassen.\nEin detaillierte Beschreibung der Funktionalität ist dem Abschnitt → 6. „Laufzeitsicht“ zu entnehmen.\nBild: Klassendiagramm des Models\nNeben den \u0026ldquo;aktiven\u0026rdquo; Klassen des Models werden auch die Routen und Frames durch Klassen repräsentiert. Diese dienen vor allem der übersichtlichen Weitergabe von Daten zwischen Methoden.\nBild: Klassendiagramm von Route, Frame und LatLng\n"
},
{
	"uri": "https://spotifast.github.io/06_laufzeitsicht/03_route_anzeigen/",
	"title": "Routen anzeigen",
	"tags": [],
	"description": "",
	"content": " 6.3 Routen anzeigen Aufgenommene Routen können vom Benutzer in der App auf einer Karte angezeigt werden. Der Ablauf hierfür ist im folgenden Diagramm dargestellt.\nBild: Auswählen und Anzeigen einer Route (Teile des eigenen Systems sind grün markiert)\nBeim Aufbauen der App wird von der View die Liste aller Routen-IDs des Benutzers angefordert. Die Routen werden dann in einer Liste angezeigt, von wo aus der Benutzer eine der Routen auswählen kann. Für die ausgewählte Route wird dann der gesamten Routeninhalt vom Server angefordert. Die Route wird dann zur Anzeige zurück an die View übergeben. Dort wird die Route in die einzelnen Frames zerlegt und auf einer Karte angezeigt.\n"
},
{
	"uri": "https://spotifast.github.io/05_bausteinsicht/04_aufbau_api/",
	"title": "Aufbau API",
	"tags": [],
	"description": "",
	"content": " 5.4 Aufbau API Im der folgenden Darstellung wird der Aufbau der API Zugriffe beschrieben.\nBild: API Zugriffe\nDer APIFassade-Klasse werden von der API Funktionen zugewiesen, die aufgerufen werden. In der untenstehenden Tabelle sind alle URLs aufgelistet, die von der API bereitgestellt werden. Die APIFassade befindet sich in src/API/allAPI.py und kann direkt auf die Datenbank zugreifen oder Daten in die Datenbank schreiben. Wenn die Funktion addFrame aufgerufen wird, wird die Hilfsklasse FrameManager verwendet, um zu überprüfen, ob das Json-Schema korrekt ist. Wenn dies der Fall ist, können die Daten der Datenbank hinzugefügt werden.\nWenn die API eine Antwort sendet, wird dies über ein Response-Objekt erledigt. Dieses Objekt wird mithilfe der jsonify-Funktion aus der Flask-Bibliothek erstellt, die ein Python-Objekt in ein JSON-Objekt umwandelt. Das Response-Objekt wird in der Klasse Response umgesetzt und mithilfe der Funktion createResponse erstellt. In diesem Zusammenhang kann auch ein DatabaseModel mit einem Schema angegeben werden, das das Objekt in ein Json-Objekt umwandelt.\n   HTTP Verb Pfad Beschreibung     POST /addRoute Erstellt eine neue Route   POST /addFrame Fügt eine neues Frame zu einer Route hinzu   GET /route/\u0026lt;id\u0026gt; gibt die Route wieder    Frame Schema Eine zentrale Funktion ist das senden von Frames an den Server. Ein Frame ist ein Datensatz, der einen Zeitpunkt einer Route beschreibt. Die Übertragung an den Server erfolgt mit dem nachfolgenden Json-Schema\n{ \u0026quot;password\u0026quot; : \u0026quot;xxx\u0026quot;, \u0026quot;version\u0026quot; : \u0026quot;2.0\u0026quot;, \u0026quot;time\u0026quot;: \u0026quot;2022-10-30 18:16:45.784911\u0026quot;, \u0026quot;route\u0026quot;: 1, \u0026quot;geo\u0026quot; : { \u0026quot;lat\u0026quot;: 0.0, \u0026quot;long\u0026quot;: 0.0 }, \u0026quot;trackId\u0026quot;: \u0026quot;753KutoAy00apPsplMRetG\u0026quot; }  Beschreibung der Attribute:\n password - Passwort, das vom Server gesetzt wurde. Dieses Passwort wird vom Client benötigt, um die Daten in die Datenbank zu speichern. version - Version des Frames. Derzeit ist nur die Version 2.0 gültig. time - Zeitpunkt, zu dem die Position aufgenommen wurde. route - Route, auf der sich die Position befindet. geo - Geokoordinaten der Position. trackId - TrackID, ist ein eindeutiger Schlüssel, des Liedes, das gerade abgespielt wurde.  "
},
{
	"uri": "https://spotifast.github.io/05_bausteinsicht/05_aufbau_datenbank/",
	"title": "Aufbau Datenbank",
	"tags": [],
	"description": "",
	"content": " 5.5 Aufbau Datenbank Bild: Physisches Schema der Datenbank\nIm Folgenden wird das physische Schema der Datenbank beschrieben. Die Datenbank besteht aus 3 Tabellen, welche in der Abbildung dargestellt sind. Die Tabellen werden im Folgenden beschrieben.\nTabelle user Die Tabelle user enthält die Daten der Benutzer. Die Daten sind die UserId und das Land des Benutzers. Die UserId ist der Primärschlüssel der Tabelle. Die UserId wird von Spotify vergeben und ist eindeutig. Die UserId wird auch als Fremdschlüssel in der Tabelle route verwendet.\nTabelle route Die Tabelle route enthält die Daten der Routen. Die Daten sind die RouteId und die UserId. Die RouteId ist der Primärschlüssel der Tabelle. Die RouteId wird von der Datenbank vergeben und ist eindeutig. Die UserId ist der Fremdschlüssel der Tabelle user. Somit hat jeder user eine oder mehrere Routen.\nTabelle position Die Tabelle position enthält die Daten der Positionen. Die Daten sind die PositionId, die RouteId, die Zeit (Aufnahemezeitpunkt der Koordinaten), die Länge- und die Breitegerade. Die PositionID ist einer Route zugeteilt und ist eindeutig.\nORM (Object Relational Mapping) Für dieses Projekt wurde ein OR Mapper verwendet. Dieser ist für die Kommunikation zwischen der Datenbank und der Anwendung zuständig. Die Anwendung kann mit dem OR Mapper Objekte erstellen, ändern und löschen. Der OR Mapper kümmert sich dann um die Kommunikation mit der Datenbank. In der Datei src/Config/config.py wird der OR Mapper konfiguriert. Dort wird der Pfad zur Datenbank angegeben. Hierbei wird die Datenbank postgresql verwendet. Die Datenbank wird mit dem Benutzer und dem Passwort auf localhost unter Port 5432 angesprochen. Die Datenbank heißt postgres. Da das Password und der User nicht im Repository gespeichert werden sollen, wird es in der Datei src/Config/config.py nicht angegeben. Hierfür wird eine Datei SpotiFastDBPassword.py angelegt. Diese Datei enthält die Variablen user und password. Diese Variablen werden dann in der Datei src/Config/config.py importiert. Außerdem wir diese Datei in der Datei .gitignore angegeben. Somit wird die Datei nicht mit dem Repository synchronisiert.\nDesweitern wird eine Klasse Base erstellt. Diese Klasse wird von allen Klassen erben, die mit der Datenbank kommunizieren. In dem Ordener Model ist hierbei alle Tabellen der Datenbank als Klassen implementiert.\n"
},
{
	"uri": "https://spotifast.github.io/01_einfuehrung/01_aufgabenstellung/",
	"title": "Aufgabenstellung",
	"tags": [],
	"description": "",
	"content": " 1.1 Aufgabenstellung Was ist SpotiFast? SpotiFast wertet aus, inwiefern das Tempo der Musik und auch andere Eigenschaften der Musik einen Einfluss auf das Fahrverhalten des Benutzers haben. Dazu gehören Eigenschaften wie Lautstärke, Tanzbarkeit, Instrumentalität und \u0026ldquo;Energie\u0026rdquo;. Des Weiteren bildet es auf einer Karte die verschiedenen Strecken ab, welche abhängig vom Lied und von der Geschwindigkeit anders farbig sind. Wann Daten gesammelt werden, entscheidet der Benutzer und jeder Zeitabschnitt wird in einer eigenen Route gespeichert, die einzeln ausgewertet wird.\n"
},
{
	"uri": "https://spotifast.github.io/01_einfuehrung/02_qualitaetsziele/",
	"title": "Qualitätsziele",
	"tags": [],
	"description": "",
	"content": " 1.2 Qualitätsziele Die folgende Tabelle beschreibt die zentralen Qualitätsziele von SpotiFast, wobei die Reihenfolge eine grobe Orientierung bezüglich der Wichtigkeit vorgibt.\n   Qualitätsziel Motivation und Erläuterung     Einladende App (Benutzbarkeit) Da SpotiFast eine App ist, die gerne und einfach von jedem genutzt werden soll, ist eine gute Verständlichkeit und Bedienbarkeit der App wichtig.   Sinnvolle Datenauswertung (Funktionalität) SpotiFast liefert dem Benutzer eine sinnvolle und richtige Datenauswertung.   Nutzbar auf iOS und Android (Portabilität) SpotiFast kann von auf Handys mit einem iOS oder Android Betriebssystem benutzt werden.    Die → 10.2 „Qualitätsszenarien“ konkretisieren diese Qualitätsziele.\n"
},
{
	"uri": "https://spotifast.github.io/01_einfuehrung/03_stakeholder/",
	"title": "Stakeholder",
	"tags": [],
	"description": "Stellt die Stakeholder von SpotiFast und ihre jeweilige Intention dar.",
	"content": " 1.3 Stakeholder Die folgende Tabelle stellt die Stakeholder von SpotiFast und ihre jeweilige Intention dar.\n   Wer? Interesse, Bezug     Benutzer:innen  wollen auf anschauliche Weise angezeigt bekommen, ob und wie ihr Fahrverhalten von ihrem Musikgeschmack abhängt möchten ihre gefahrenen Routen und gehörten Lieder sehen wollen schnelle Reaktionszeiten und wenig Speicherverbrauch   Professor  Lernerfolg der Studenten strukturiertes und arbeitsteiliges Vorgehen im Projekt  Umsetzung der in den Vorlesungen vermittelten Inhalte (verteilte Systeme, Datenbanken, Entwurfsmuster, automatisierte Tests, \u0026hellip;)  Erfüllung des Auftrags    Studierende  Lernerfolg Erfüllung des Auftrags  Benutzung der App Spaß    "
},
{
	"uri": "https://spotifast.github.io/",
	"title": "SpotiFast Dokumentation (SWE2 2022)",
	"tags": [],
	"description": "",
	"content": ""
}]